# 노드 3장  
### 1. 노드로 자바스크립트를 실행하는 방법  
- **REPL (Read Eval Print Loop)**  
  `node`명령어로 노드에서 자바스크립트 즉시 실행 입력기로 브라우저 콘솔 탭과 기능이 같다.  
- **JS 파일 실행**  
  `node [file-path]`명령어로 자바스크립트 파일을 직접 실행할 수도 있다.  
- **모듈로 만들기**  
  `module.exports`명령어를 통해 파일(혹은 디렉터리)을 모듈화할 수 있다.  
  모듈의 주체는 객체, 변수, 함수가 될 수 있다.  
  `require('file-path')`명령어를 통해 모듈을 불러올 수 있다.  
  노드에서는 여러개의 모듈을 조합하여 다양한 형태로 제공된다.  

### 2. 노드 내장 객체  
- **global**  
  브라우저의 window객체와 같은 전역객체이다. 객체 내부에는 많은 속성들이 있다.  
  - **console**  
    디버깅을 위한 객체이다. `console.time`, `console.log`, `console.dir`, `console.error` 등 여러 메서드가 존재한다.  
  - **타이머**  
    타이머 기능을 제공하는 `setTimeout()`, `setInterval()`, `setImmediate()` 함수가 있다.  이 타이머 함수들은 모두 아이디를 반환하는데 `clear`라는 prefix의 각 함수로 타이머를 취소할 수 있다.  
  - **__filename, __dirname**  
    현재 파일의 경로나 파일명의 정보를 제공한다. 경로가 문자열로 제공되기도 하고, 경로 구분자 문제도 있어 보통 `path` 모듈을 사용한다.  
  - **module, exports**  
    모듈을 만들 때 사용하는 객체. `module.exports`와 `exports`는 같은 객체를 참조하고 있다.  
  - **process**  
    현제 실행되고 있는 노드 프로세스에 대한 정보를 담은 객체  
    - `process.env`: 시스템의 환경변수, 주로 서비스의 중요한 키를 저장하는 공간으로 사용된다.  
    - `process.nextTick()`: 이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리한다.  
    - `process.exit()`: 노드 프로세스를 종료한다. 서버 프로그래밍에선 사용되지 않는다.  

### 3. 노드 내장 모듈
모듈의 Api는 책 내용 참고 (후에 추가 예정?)
- `os`  
  운영체제의 정보가 담겨져 있는 모듈, 일반적인 웹 서비스를 제작할 때에는 사용빈도가 높지 않지만 운영체제별로 다른 서비스를 제공하거나 컴퓨터 내부 자원에 빈번하게 접근하는 경우 사용된다.  
- `path`  
  폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈.  
- `url`  
  인터넷 주소를 쉽게 조작하도록 도와주는 모듈.  
  WHATWG와 노드의 url방식 중 취향에 따라 사용하면 되지만 주소가 host부분 없이 pathname 부분만 오는 경우 노드의 url방식을 써야한다. WHATWG 방식에서 search부분을 쉽게 조작할 수 있는 searchParams객체를 사용하면 더 유용하다. 노드의 url방식에서 query의 경우 `querystring` 모듈을 한 번 더 사용해야하기 때문이다.
- `crypto`  
  다양한 방식의 암호화를 도와주는 모듈.  
- `util`  
  각종 편의 기능을 모아둔 모듈.  

### 4. 파일 시스템
fs 모듈은 파일 시스템에 접근하는 모듈이다. (파일 생성, 삭제, 읽고, 쓰기, 폴더 생성, 삭제 등등..)  
- 동기 메서드(Sync가 붙어 있음)와 비동기 메서드  
  노드는 대부분의 메서드를 비동기 방식으로 처리한다. 수백 개의 I/O 요청이 들어와도 메인 스레드는 백그라운드에 요청 처리를 위임하고 나중에 백그라운드가 각각의 요청 처리가 완료되었다고 알리면 그때 콜백 함수를 처리한다.
  동기 메서드를 사용하면 코드는 훨씬 더 이해하기 쉽지만 수백 개 이상 요청이 들어왔을 때 성능에 문제가 생긴다. 즉, 백그라운드가 작업하는 동안 메인 스레드는 대기하고 있어야 한다. 동기 메서드보다 비동기 메서드를 사용하는 것이 훨씬더 효율 적이다.

- 버퍼와 스트림
  파일을 읽거나 쓰는 방식에 버퍼를 이용하는 방식과 스트림을 이용하는 방식이 있다. 
  **Buffer**를 사용한 방식은 메모리에 파일 크기만큼 공간을 마련해두며, 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있게 한다. (메모리에 저장된 데이터가 버퍼) 용량이 대용량이거나 서버 같이 몇 명이 이용할 지 모르는 환경에서는 메모리 문제가 발생할 수 있다.  
    - 관련 메서드: readFile 메서드, Buffer객체의 메서드들  
  
  **Stream**을 사용한 방식은 버퍼의 크기를 작게 만들어 여러 번에 나누어 보내는 방식이며, 스트림끼리 연결하는 것을 스트림한다고 표현한다.  
    - createReadStream 메서드, createWriteStream 메서드, pipe 메서드  

기타 fs 메서드 Api는 책 참고.  

### 5. 이벤트  
`events`모듈 사용한다.  
- on: 이벤트 이름과 이벤트 발생 시의 콜백을 연결한다. (=addListener)  
- emit: 이벤트를 호출하는 메서드이다.  
- off: 이벤트에 연결된 리스너를 제거한다 (=removeListener)  
추가적인 Api는 책 참고.  

### 6. 예외 처리  
노드에서는 예외 처리가 정말 중요하다. 멀티 스레드 프로그램에서는 스레드 하나가 멈추면 다른 스레드가 그 일을 대신하지만 노드는 스레드가 하나뿐이므로 예외로 인해 멈추지 않게 처리를 잘해주어야 한다. 에러 발생 부분을 `try catch` 문으로 감싸주면 된다.  
예측이 불가능한 에러는 `process` 객체에 `uncaghtException` 이벤트 리스너를 달아주어 처리해줄 수 있지만 노드는 `uncaughtException` 이벤트 발생 후 다음 동작이 제대로 동작하는지를 보증하지 않는다. 따라서 process.exit 메서드로 종료하는 것이 좋다. 운영 중인 서버에서 프로세스가 종료되었을 때 재시작하는 방법을 15장에서 살펴볼 것이다.  
서버 운영은 에러와의 싸움이다. 모든 에러 상황에 대비하는 것이 최선이지만 시간이나 비용 인력 등의 제약으로 대비하지 못한 에러가 있을 수 있다. 따라서 에러 발생 시 철저히 로깅하고 주기적으로 로그를 확인하면서 보완해 나가야 한다.

